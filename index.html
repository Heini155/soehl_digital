<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Soehl Digital</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Soehl Digital – Engineering, KI, Software, Web.">
<meta name="robots" content="index,follow">
<link rel="canonical" href="https://soehl.digital/">

<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://soehl.digital/">
<meta property="og:title" content="Söhl Digital">
<meta property="og:description" content="Engineering · KI · Software · Web">
<meta property="og:image" content="https://soehl.digital/og.png">

<meta name="twitter:card" content="summary_large_image">
<link rel="icon" href="/favicon.svg" type="image/svg+xml">

<style>
/* ===============================
   LOCAL FONT: Orbitron
   =============================== */
@font-face {
  font-family: "OrbitronLocal";
  src: url("/assets/fonts/orbitron-400.woff2") format("woff2");
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "OrbitronLocal";
  src: url("/assets/fonts/orbitron-600.woff2") format("woff2");
  font-weight: 600;
  font-style: normal;
  font-display: swap;
}

/* =============================== */

:root { color-scheme: dark; }

html, body {
  margin: 0;
  height: 100%;
  background: #000;
  color: #00FFCC;
  font-family:
    "OrbitronLocal",
    "Bahnschrift",
    "OCR A Extended",
    "Segoe UI",
    system-ui,
    sans-serif;
}

/* --- STARFIELD --- */
#starfield{
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  pointer-events: none;
}

/* --- CONTENT --- */
.panel {
  position: relative;
  z-index: 2;
  max-width: 880px;
  margin: 2rem auto;
  padding: 1.4rem 1.4rem 1.8rem;
  background: rgba(0,10,30,.82);
  border: 2px solid rgba(0,255,204,.9);
  border-radius: 14px;
  box-shadow: 0 0 30px rgba(0,255,204,.35);
}

@supports not ((-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px))) {
  .panel {
    background: rgba(0,10,30,.60);
  }
  .navbar,
  .sound-toggle {
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
  }
}

h1 {
  text-align: center;
  font-size: 2.6rem;
  letter-spacing: .12em;
  margin: .3rem 0 .4rem;
  text-transform: uppercase;
  text-shadow: 0 0 10px rgba(0,255,204,.4);
}

.tagline {
  text-align: center;
  letter-spacing: .08em;
  opacity: .95;
  margin-bottom: 1.2rem;
  text-shadow: 0 0 6px rgba(0,255,204,.25);
}

.navbar {
  display: flex;
  justify-content: center;
  gap: 1.4rem;
  padding: .7rem;
  margin-bottom: 1.5rem;
  background: rgba(0,10,30,.6);
  border: 1px solid rgba(0,255,204,.35);
  border-radius: 12px;
  backdrop-filter: blur(8px);
}

.navbar a {
  color: #00FFCC;
  text-decoration: none;
  text-transform: uppercase;
  font-size: .85rem;
  letter-spacing: .14em;
  border-bottom: 1px dotted rgba(0,255,204,.7);
}

.navbar a:hover {
  color: #fff;
  border-color: #fff;
}

h2 {
  font-size: 1.25rem;
  letter-spacing: .08em;
  text-transform: uppercase;
  border-bottom: 1px solid rgba(0,255,204,.55);
  padding-bottom: .3rem;
  margin-top: 1.6rem;
}

p {
  font-size: 1.05rem;
  line-height: 1.55;
  opacity: .92;
}

.contact-mail {
  text-decoration: none;
  border-bottom: none;
  opacity: .9;
  color: #00FFCC;
  border-bottom: 1px dotted rgba(0,255,204,.7);
}

.contact-mail:hover {  
  color: #fff;
  border-bottom: 1px dotted #fff;
}


footer {
  text-align: center;
  margin-top: 2.4rem;
  font-size: .85rem;
  opacity: .85;
  letter-spacing: .06em;

  display: flex;
  flex-direction: column;
  align-items: center;
  gap: .45rem;
}

footer a{
  color:#00FFCC;
  text-decoration:none;
  border-bottom: 1px dotted rgba(0,255,204,.7);
}
footer a:hover{
  color:#fff;
  border-color:#fff;
}

/* --- Footer layout refinement --- */
.footer-links {
  margin-bottom: .4rem;
}

.footer-copy {
  font-size: .75rem;
  opacity: .75;
  letter-spacing: .08em;
}


/* --- SOUND TOGGLE (bottom-right in panel) --- */
.sound-toggle{
  position: absolute;
  right: 14px;
  bottom: 14px;
  z-index: 10;
  width: 34px;
  height: 34px;
  display: grid;
  place-items: center;
  background: rgba(0,10,30,.45);
  border: 1px solid rgba(0,255,204,.35);
  border-radius: 10px;
  cursor: pointer;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  backdrop-filter: blur(8px);
  opacity: .85;
  pointer-events: auto;
}
.sound-toggle:hover { opacity: 1; border-color: rgba(0,255,204,.65); }
.sound-toggle svg { width: 18px; height: 18px; fill: none; stroke: #00FFCC; stroke-width: 2; }
.sound-toggle .slash { display: none; }
.sound-toggle.muted .slash { display: block; }
.sound-toggle.muted .waves { opacity: .18; }

/* --- PRECLICK: sound button neon-orange pulse (only before first click) --- */
@keyframes neonPulse {
  0%   { box-shadow: 0 0 0 rgba(255,140,0,0); transform: scale(1); }
  50%  { box-shadow: 0 0 18px rgba(255,140,0,.6), 0 0 40px rgba(255,80,0,.3); transform: scale(1.06); }
  100% { box-shadow: 0 0 0 rgba(255,140,0,0); transform: scale(1); }
}
.sound-toggle.preclick{
  border-color: rgba(255,140,0,.8);
  background: rgba(30,10,0,.55);
  animation: neonPulse 1.2s ease-in-out infinite;
  opacity: 1;
}
.sound-toggle.preclick svg{ stroke:#FF8C00; }
.sound-toggle.preclick .slash{ display:block; }
.sound-toggle.preclick .waves{ opacity:.12; }

/* --- CENTER SONG PLAY BUTTON --- */
.track-center{
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 1.6rem 0 1.2rem;
}

.track-btn{
  width: 64px;
  height: 64px;
  border-radius: 50%;
  display: grid;
  place-items: center;
  background: rgba(0,0,0,.25);
  border: 2px solid rgba(0,255,204,.55);
  cursor: pointer;
  filter: drop-shadow(0 0 14px rgba(0,255,204,.25));
  transition: transform .12s ease, opacity .2s ease, border-color .2s ease;
}

.track-btn,
.sound-toggle {
  -webkit-tap-highlight-color: transparent;
  -webkit-appearance: none;
  appearance: none;
}

.track-btn:focus,
.sound-toggle:focus {
  outline: none;
}

.track-btn:focus-visible,
.sound-toggle:focus-visible {
  outline: 2px solid rgba(0,255,204,.55);
  outline-offset: 4px;
  border-radius: 999px;
}

.track-btn:hover{ transform: scale(1.05); }
.track-btn:active{ transform: scale(.98); }

.track-btn svg{
  width: 28px;
  height: 28px;
  fill: none;
  stroke: #00FFCC;
  stroke-width: 2.4;
  stroke-linejoin: round;
  stroke-linecap: round;
}

.track-btn .icon-stop{ display:none; }
.track-btn.playing .icon-play{ display:none; }
.track-btn.playing .icon-stop{ display:block; }

/* Disabled (before sound unlock / when muted) */
.track-btn[disabled]{
  cursor: not-allowed;
  opacity: .35;
  filter: none;
  border-color: rgba(0,255,204,.35);
}
.track-btn[disabled] svg{
  stroke: rgba(0,255,204,.7);
}

/* Orange pulse AFTER sound unlocked */
.track-btn.armed{
  border-color: rgba(255,140,0,.9);
  animation: neonPulse 1.2s ease-in-out infinite;
  filter: drop-shadow(0 0 18px rgba(255,140,0,.35));
}
.track-btn.armed svg{
  stroke: #FF8C00;
}

/* --- Mobile fixes --- */
@media (max-width: 560px) {
  .panel{
    margin: 1rem auto;
    padding: 1.1rem 1.0rem 1.3rem;
  }
  h1{
    font-size: 2.05rem;
    letter-spacing: .10em;
  }
  .tagline{
    font-size: .95rem;
    letter-spacing: .06em;
  }
  .navbar{
    flex-wrap: wrap;
    gap: .7rem 1.0rem;
    padding: .65rem .7rem;
  }
  .navbar a{
    font-size: .78rem;
    letter-spacing: .10em;
    white-space: nowrap;
  }
  .sound-toggle{
    top: auto;
    right: 14px;
    bottom: 14px;
  }
}

/* Accessibility */
@media (prefers-reduced-motion: reduce) {
  #starfield { display: none; }
  .sound-toggle.preclick, .track-btn.armed { animation: none; }
}
</style>
</head>

<body>

<canvas id="starfield"></canvas>

<div class="panel">
  <h1>Soehl Digital</h1>
  <div class="tagline">Engineering · KI · Software · Web</div>

  <nav class="navbar">
    <a href="#info">Info</a>
    <a href="#kontakt">Kontakt</a>
  </nav>

  <section id="info">
    <h2>Info</h2>
    <p>Technische Projekte, Experimente und Demos</p>
  </section>

  <section id="kontakt">
    <h2>Kontakt</h2>
    <p><a href="mailto:kontakt@soehl.digital" class="contact-mail">kontakt@soehl.digital</a></p>
  </section>

  <section id="track">
    <div class="track-center">
      <button id="trackBtn" class="track-btn" type="button" disabled aria-label="Play">
        <!-- Play -->
        <svg class="icon-play" viewBox="0 0 24 24">
          <path d="M8 6l12 6-12 6z"></path>
        </svg>
        <!-- Stop -->
        <svg class="icon-stop" viewBox="0 0 24 24">
          <path d="M7 7h10v10H7z"></path>
        </svg>
      </button>

      <audio id="trackAudio" preload="auto">
        <source src="soul_digital.mp3" type="audio/mpeg">
      </audio>
    </div>
  </section>

  <footer>
    <div class="footer-links">
      <a href="/impressum.html">Impressum</a> ·
      <a href="/datenschutz.html">Datenschutz</a>
    </div>
    <div class="footer-copy">
      © <span id="year"></span> SOEHL DIGITAL
    </div>
  </footer>

  <!-- Sound button INSIDE panel -->
  <button class="sound-toggle muted preclick" id="soundBtn" type="button"
          aria-label="Sound umschalten" title="Sound">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M4 10v4h3l4 3V7L7 10H4z" />
      <path class="waves" d="M15.5 9.5a3.5 3.5 0 0 1 0 5" />
      <path class="waves" d="M17.8 7.2a6.5 6.5 0 0 1 0 9.6" />
      <path class="slash" d="M3 3l18 18" />
    </svg>
  </button>
</div>

<script>
(() => {
  // Canonical Host: redirect www -> non-www
  if (location.hostname === "www.soehl.digital") {
    location.replace("https://soehl.digital" + location.pathname + location.search + location.hash);
    return;
  }

  document.getElementById("year").textContent = new Date().getFullYear();

  // DOM refs early (used by starfield centering)
  const soundBtn   = document.getElementById("soundBtn");
  const trackBtn   = document.getElementById("trackBtn");
  const trackAudio = document.getElementById("trackAudio");

  function isTrackPlaying() {
    return trackAudio && !trackAudio.paused && !trackAudio.ended;
  }

  /* ===============================
     STARFIELD + Warp: song-driven
     + center aligns to track button during warp
     =============================== */
  const canvas = document.getElementById("starfield");
  const ctx = canvas.getContext("2d", { alpha: false });

  let w=0, h=0, cx=0, cy=0, dpr=1;
  let targetCX = 0, targetCY = 0;
  let stars = [];

  const BASE_SPEED = 1.25;
  const MAX_SPEED  = 32;

  const WARP_UP_SECONDS   = 30.0; // accelerate to warp
  const WARP_DOWN_SECONDS = 3.0;  // brake back to base

  let speed = BASE_SPEED;

  // transition state
  let warpActive = false;
  let transFrom = BASE_SPEED;
  let transTo = BASE_SPEED;
  let transStart = 0;
  let transDur = 0;

  // animation run state
  let rafId = 0;
  let running = false;

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function easeInOut(t){
    t = clamp(t, 0, 1);
    return t * t * (3 - 2 * t);
  }

  function resize() {
    dpr = window.devicePixelRatio || 1;
    w = Math.floor(window.innerWidth * dpr);
    h = Math.floor(window.innerHeight * dpr);
    canvas.width = w;
    canvas.height = h;

    // current center (smoothed towards target)
    cx = w / 2;
    cy = h / 2;

    // default target is viewport center
    targetCX = cx;
    targetCY = cy;

    const count = Math.min(1500, Math.floor((window.innerWidth * window.innerHeight) / 1800));
    stars = Array.from({ length: count }, () => newStar(true));
  }

  function newStar(randomZ) {
    return {
      x: (Math.random() * 2 - 1) * (w/2),
      y: (Math.random() * 2 - 1) * (h/2),
      z: randomZ ? Math.random() * (w/2) : (w/2)
    };
  }

  function setWarp(on, now) {
    if (warpActive === on) return;

    warpActive = on;
    transFrom = speed;
    transTo = on ? MAX_SPEED : BASE_SPEED;
    transStart = now;
    transDur = (on ? WARP_UP_SECONDS : WARP_DOWN_SECONDS) * 1000;
  }

  function updateSpeed(now) {
    if (!transDur) return;
    const t = (now - transStart) / transDur;
    const k = easeInOut(t);
    speed = transFrom + (transTo - transFrom) * k;
    if (t >= 1) {
      speed = transTo;
      transDur = 0;
    }
  }

  function centerOnTrackButton() {
    if (!trackBtn) return;
    const rect = trackBtn.getBoundingClientRect();
    const x = rect.left + rect.width / 2;
    const y = rect.top  + rect.height / 2;
    targetCX = x * dpr;
    targetCY = y * dpr;
  }

  function centerOnViewport() {
    targetCX = w / 2;
    targetCY = h / 2;
  }

  function draw(now) {
    if (!running) return;

    updateSpeed(now);

    // smooth center follow (so it's visually elegant)
    const FOLLOW = 0.005; 
    cx += (targetCX - cx) * FOLLOW;
    cy += (targetCY - cy) * FOLLOW;

    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, w, h);

    const v = speed;
    const halfW = w / 2;

    for (let i = 0; i < stars.length; i++) {
      const s = stars[i];

      const k = 128 / s.z;
      const x = s.x * k + cx;
      const y = s.y * k + cy;

      s.z -= v;

      if (s.z <= 1 || x < 0 || x > w || y < 0 || y > h) {
        stars[i] = newStar(false);
        continue;
      }

      const t = 1 - s.z / halfW;
      const alpha = Math.min(1, t + 0.25);
      const r = Math.max(0.7 * dpr, t * 2.5 * dpr);

      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(220,255,250,${alpha})`;
      ctx.fill();
    }

    audioTick();
    rafId = requestAnimationFrame(draw);
  }

  function startAnim() {
    if (running) return;
    running = true;
    rafId = requestAnimationFrame(draw);
  }

  function stopAnim() {
    running = false;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = 0;
  }

  function pokeActivity() {
    // during song we always keep animation alive
    if (!running) startAnim();
  }

  window.addEventListener("resize", () => {
    resize();
    // keep the chosen center consistent after resize
    if (isTrackPlaying()) centerOnTrackButton();
    else centerOnViewport();
    pokeActivity();
  });

  window.addEventListener("visibilitychange", () => {
    if (document.hidden) stopAnim();
    else startAnim();
  });

  window.addEventListener("load", () => {
    resize();
    startAnim();
  });

  /* ===============================
     AUDIO (starts only on sound button click)
     =============================== */
  let audioCtx = null;
  let master = null;

  let humGain = null;
  let warpGain = null;

  let humLP = null;
  let warpBP = null;
  let warpLP = null;

  let startedAudio = false;
  let muted = true;             // DEFAULT OFF
  let soundUnlocked = false;    // becomes true after first soundBtn click
  let trackArmedShown = false;  // orange pulse only once after unlock
  let trackEverUsed = false;

  function createNoiseBuffer(ctx, seconds = 2.0) {
    const sampleRate = ctx.sampleRate;
    const length = Math.floor(sampleRate * seconds);
    const buffer = ctx.createBuffer(1, length, sampleRate);
    const data = buffer.getChannelData(0);

    let last = 0;
    for (let i = 0; i < length; i++) {
      const white = Math.random() * 2 - 1;
      last = (last + 0.02 * white) / 1.02;
      data[i] = last * 2.0;
    }
    return buffer;
  }

  function startAudio() {
    if (startedAudio) return;
    startedAudio = true;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    master = audioCtx.createGain();
    master.gain.value = 0.0; // muted at start
    master.connect(audioCtx.destination);

    // Base hum
    const humSrc = audioCtx.createBufferSource();
    humSrc.buffer = createNoiseBuffer(audioCtx, 2.0);
    humSrc.loop = true;

    humLP = audioCtx.createBiquadFilter();
    humLP.type = "lowpass";
    humLP.frequency.value = 140;
    humLP.Q.value = 0.7;

    const humHP = audioCtx.createBiquadFilter();
    humHP.type = "highpass";
    humHP.frequency.value = 18;
    humHP.Q.value = 0.7;

    humGain = audioCtx.createGain();
    humGain.gain.value = 0.85;

    const humLFO = audioCtx.createOscillator();
    humLFO.type = "sine";
    humLFO.frequency.value = 0.08;
    const humLFOGain = audioCtx.createGain();
    humLFOGain.gain.value = 0.10;
    humLFO.connect(humLFOGain).connect(humGain.gain);

    humSrc.connect(humLP).connect(humHP).connect(humGain).connect(master);
    humSrc.start();
    humLFO.start();

    // Warp layer
    const warpSrc = audioCtx.createBufferSource();
    warpSrc.buffer = createNoiseBuffer(audioCtx, 1.2);
    warpSrc.loop = true;

    warpBP = audioCtx.createBiquadFilter();
    warpBP.type = "bandpass";
    warpBP.frequency.value = 260;
    warpBP.Q.value = 0.9;

    warpLP = audioCtx.createBiquadFilter();
    warpLP.type = "lowpass";
    warpLP.frequency.value = 520;
    warpLP.Q.value = 0.7;

    warpGain = audioCtx.createGain();
    warpGain.gain.value = 0.0;

    const warpLFO = audioCtx.createOscillator();
    warpLFO.type = "sine";
    warpLFO.frequency.value = 0.22;
    const warpLFOGain = audioCtx.createGain();
    warpLFOGain.gain.value = 0.18;
    warpLFO.connect(warpLFOGain).connect(warpGain.gain);

    warpSrc.connect(warpBP).connect(warpLP).connect(warpGain).connect(master);
    warpSrc.start();
    warpLFO.start();
  }

  function ensureAudioFromSoundButton() {
    startAudio();
    if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
  }

  function applyMute(immediate = false) {
    soundBtn.classList.toggle("muted", muted);

    if (master && audioCtx) {
      const target = muted ? 0.0 : 0.12;
      if (immediate) master.gain.value = target;
      else master.gain.setTargetAtTime(target, audioCtx.currentTime, 0.03);
    }

    const canUseTrack = soundUnlocked && !muted;
    trackBtn.disabled = !canUseTrack;

    // if muted while playing -> stop (and release wake lock, brake warp)
    if (muted) stopTrack(true);

    if (canUseTrack && !trackEverUsed && !trackArmedShown) {
      trackBtn.classList.add("armed");
      trackArmedShown = true;
    }
    if (!canUseTrack) {
      trackBtn.classList.remove("armed");
    }
  }

  function audioTick() {
    if (!startedAudio || !audioCtx || !humGain || !warpGain) return;

    const norm = (speed - BASE_SPEED) / (MAX_SPEED - BASE_SPEED);
    const n = Math.max(0, Math.min(1, norm));

    const humLevel = 0.75 + n * 0.35;
    humGain.gain.setTargetAtTime(humLevel, audioCtx.currentTime, 0.05);

    if (humLP) {
      const humCut = 140 + n * 140;
      humLP.frequency.setTargetAtTime(humCut, audioCtx.currentTime, 0.06);
    }

    const warpAmount = Math.max(0, (n - 0.20) / 0.80);
    const warpLevel = warpAmount * 0.95;
    warpGain.gain.setTargetAtTime((muted ? 0 : warpLevel), audioCtx.currentTime, 0.06);

    if (warpBP) {
      const bp = 240 + n * 220;
      warpBP.frequency.setTargetAtTime(bp, audioCtx.currentTime, 0.06);
    }
    if (warpLP) {
      const lp = 520 + n * 380;
      warpLP.frequency.setTargetAtTime(lp, audioCtx.currentTime, 0.06);
    }
  }

  /* ===============================
     Wake Lock: keep screen on while track plays
     =============================== */
  let wakeLock = null;

  async function requestWakeLock() {
    try {
      if (!("wakeLock" in navigator)) return;
      wakeLock = await navigator.wakeLock.request("screen");
      wakeLock.addEventListener("release", () => { wakeLock = null; });
    } catch (_) {
      wakeLock = null;
    }
  }

  async function releaseWakeLock() {
    try { if (wakeLock) await wakeLock.release(); } catch (_) {}
    wakeLock = null;
  }

  document.addEventListener("visibilitychange", () => {
    // lock might be dropped on background; reacquire when coming back and still playing
    if (!document.hidden && isTrackPlaying()) requestWakeLock();
  });

  /* ===============================
     Track control -> drives warp + center + wake lock
     =============================== */
  function setTrackUIPlaying(on) {
    trackBtn.classList.toggle("playing", on);
    trackBtn.setAttribute("aria-label", on ? "Track stoppen" : "Track abspielen");
  }

  function stopWarpSmooth() {
    setWarp(false, performance.now());
  }

  function startWarpSmooth() {
    setWarp(true, performance.now());
  }

  function stopTrack(forceReset = false) {
    if (!trackAudio) return;
    trackAudio.pause();
    releaseWakeLock();

    if (forceReset) trackAudio.currentTime = 0;

    setTrackUIPlaying(false);
    stopWarpSmooth();

    // center back to viewport
    centerOnViewport();
    pokeActivity();
  }

  async function playTrack() {
    if (trackBtn.disabled) return;

    trackEverUsed = true;
    trackBtn.classList.remove("armed");

    pokeActivity();

    try { trackAudio.load(); } catch(_) {}

    try {
      await trackAudio.play();
      await requestWakeLock();

      setTrackUIPlaying(true);

      // center exactly on the button (then warp)
      centerOnTrackButton();
      requestAnimationFrame(() => startWarpSmooth());
    } catch (err) {
      stopTrack(true);
    }
  }

  trackAudio.addEventListener("ended", () => {
    stopTrack(true);
  });

  trackBtn.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (trackBtn.disabled) return;

    if (isTrackPlaying()) stopTrack(true);
    else playTrack();
  });

  // Sound button: first click unlocks + starts audio context
  let soundBtnEverClicked = false;

  soundBtn.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();

    if (!soundBtnEverClicked) {
      soundBtnEverClicked = true;
      soundBtn.classList.remove("preclick");
      soundUnlocked = true;

      // pre-buffer the track right after unlock to reduce first-play stutter
      try { trackAudio.load(); } catch(_) {}
    }

    ensureAudioFromSoundButton();

    muted = !muted;
    applyMute(false);
    pokeActivity();
  });

  // initial state
  applyMute(true);

})();
</script>

</body>
</html>
